# [테트로미노](https://www.acmicpc.net/problem/14500)

- [강지웅](#강지웅)
- [서예진](#서예진)
- [오나연](#오나연)
- [이주형](#이주형)
- [정윤영](#정윤영)

![image](https://user-images.githubusercontent.com/50551349/163186477-50791304-41da-4dad-81a4-d170e9265e1f.png)

## 강지웅
```java

```
## 서예진
```java

```

## 오나연
```java

```

## 이주형
```java
```

## 정윤영
```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

public class BOJ_14500 {

    static int[][] arr;
    static int N, M, max;
    static ArrayList<Integer> comb;
    static int[][] deltas = {{-1, 0}, {0, -1}, {0, 1}, {1,0}};
    static boolean[][] isVisited;

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());

        N = Integer.parseInt(st.nextToken());
        M = Integer.parseInt(st.nextToken());

        arr = new int[N][M];
        ArrayList<Integer> temp = new ArrayList<>();
        for(int i=0; i<N; i++){
            st = new StringTokenizer(br.readLine());
            for(int j=0; j<M; j++){
                arr[i][j] = Integer.parseInt(st.nextToken());
            }
        }
        /*
        //시간초과
        comb = new ArrayList<>();
        combination(0,0);
        */
        isVisited = new boolean[N][M];
        for(int i=0; i<N; i++){     //모든 곳에서 dfs
            for(int j=0; j<M; j++){
                isVisited[i][j] = true;
                dfs(i, j, 1, arr[i][j]);
                isVisited[i][j] = false;
            }
        }

        System.out.println(max);
    }

    public static void dfs(int r, int c, int cnt, int sum){
        if(cnt==4){
            max = Math.max(max, sum);
            return;
        }

        for(int i=0; i<4; i++){
            int dr = r + deltas[i][0];
            int dc = c + deltas[i][1];
            if(checkBoundary(dr, dc) && !isVisited[dr][dc]){
                isVisited[dr][dc] = true;
                dfs(dr, dc, cnt+1, sum+arr[dr][dc]);
                isVisited[dr][dc] = false;

                if(cnt == 2){       //ㅗ,ㅜ,ㅓ,ㅏ
                    isVisited[dr][dc] = true;
                    dfs(r, c, cnt+1, sum+arr[dr][dc]);
                    isVisited[dr][dc] = false;
                }
            }
        }

    }


    public static void combination(int start, int r){
        if(r==4) {
            int sum = calcSum();
            if (sum > max && isConnected()) {
                max = sum;
            }
            return;
        }

        for(int i=start; i<N*M; i++){
            comb.add(i);        //위치 저장
            combination(i+1, r+1);
            comb.remove(r);
        }
    }

    public static boolean isConnected(){
        Queue<Integer> queue = new LinkedList<>();
        queue.add(comb.get(0));
        isVisited[comb.get(0)/M][comb.get(0)%M] = true;
        int cnt = 1;

        while(!queue.isEmpty()){
            if(cnt==4){
                return true;
            }
            int temp = queue.poll();
            int r = temp/M;
            int c = temp%M;
            for(int i=0; i<4; i++){
                int dr = r + deltas[i][0];
                int dc = c + deltas[i][1];
                if(comb.contains(dr*M + dc) && checkBoundary(dr, dc) && !isVisited[dr][dc]){
                    queue.add(dr*M + dc);
                    isVisited[dr][dc] = true;
                    cnt++;
                }
            }
        }

        return false;
    }

    public static int calcSum(){
        int sum = 0;
        for(int i=0; i<4; i++){
            sum += arr[comb.get(i)/M][comb.get(i)%M];
        }
        return sum;
    }

    public static boolean checkBoundary(int dr, int dc){
        return dr>=0 && dc>=0 && dr<N && dc<M;
    }
}
```
