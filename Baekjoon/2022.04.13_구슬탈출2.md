# [구슬탈출2](https://www.acmicpc.net/problem/13460)

## 강지웅
```java

```
## 서예진
```java

```

## 오나연
```java

```

## 이주형
```java
```

## 정윤영
```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.LinkedList;
import java.util.Queue;
import java.util.StringTokenizer;

public class BOJ_13460 {

    static char[][] arr;
    static int[][] deltas = {{1,0}, {-1,0}, {0,1}, {0,-1}};
    static Pos redPos, bluePos, hole;
    static boolean isVisited[][][][];
    static int count = -1;

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        StringTokenizer st = new StringTokenizer(br.readLine());
        int N = Integer.parseInt(st.nextToken());
        int M = Integer.parseInt(st.nextToken());

        arr = new char[N][M];
        isVisited = new boolean[N][M][N][M];        //앞에 2개는 빨 뒤에 두개는 파
        for(int i=0; i<N; i++){
            String str = br.readLine();
            for(int j=0; j<M; j++){
                arr[i][j] = str.charAt(j);
                if(arr[i][j] == 'R'){
                    redPos = new Pos(i, j, 0);
                }else if(arr[i][j] == 'B'){
                    bluePos = new Pos(i, j, 0);
                }else if(arr[i][j] == 'O'){
                    hole = new Pos(i, j, 0);
                }
            }
        }
        bfs();
        System.out.println(count);
    }

    //최소 경로 -> 4방탐색 bfs
    public static void bfs(){
        Queue<Pos> redQ = new LinkedList<>();
        Queue<Pos> blueQ = new LinkedList<>();
        redQ.add(redPos);
        blueQ.add(bluePos);

        //방문처리 어떻게 하지
        //4차원 배열 아닌거같은데... 둘다 같이 움직인 위치 확인 어떻게 하지...
        isVisited[redPos.r][redPos.c][bluePos.r][bluePos.c] = true;

       while(!redQ.isEmpty() && !blueQ.isEmpty()){
           Pos red = redQ.poll();
           Pos blue = blueQ.poll();
           //백트래킹
           if(red.cnt > 10){
               count = -1;
               return;
           }

           //파란색 나감
           if(arr[blue.r][blue.c] == 'O'){
               continue;
           }

           //빨간색 나감 & 파란색 안나감(위에서 continue로 처리) -> 성공
           if(arr[red.r][red.c] == 'O'){
               count = red.cnt;
               return;
           }

           for(int i=0; i<4; i++){
               int rr = red.r;
               int rc = red.c;
               int br = blue.r;
               int bc = blue.c;

               //빨간 구슬
               while(true){
                   rr += deltas[i][0];
                   rc += deltas[i][1];
                   if(arr[rr][rc] == 'O'){
                       break;
                   }else if(arr[rr][rc] == '#'){  //벽 만나면 그 전에 멈춰야됨
                       rr -= deltas[i][0];
                       rc -= deltas[i][1];
                       break;
                   }
               }

               //파란 구슬
               while(true) {
                   br += deltas[i][0];
                   bc += deltas[i][1];
                   if (arr[br][bc] == 'O') {
                       break;
                   } else if (arr[br][bc] == '#') {
                       br -= deltas[i][0];
                       bc -= deltas[i][1];
                       break;
                   }
               }

               //구슬 위치가 동일한 경우
               if(rr == br && rc == bc && arr[rr][rc] != 'O'){
                   //조금 움직인게 원래 더 가까웠던 것
                   int rDis = Math.abs(red.r - rr) + Math.abs(red.c - rc);
                   int bDis = Math.abs(blue.r - br) + Math.abs(blue.c - bc);

                   if(rDis > bDis){
                       rr -= deltas[i][0];
                       rc -= deltas[i][1];
                   }else{
                       br -= deltas[i][0];
                       bc -= deltas[i][1];
                   }
               }

               //무한루프 방지용 방문처리
               if(!isVisited[rr][rc][br][bc]){
                   isVisited[rr][rc][br][bc] = true;
                   redQ.add(new Pos(rr, rc, red.cnt+1));
                   blueQ.add(new Pos(br, bc, blue.cnt+1));
               }
           }

       }

    }

    public static class Pos{
        int r;
        int c;
        int cnt;

        public Pos(int r, int c, int cnt){
            this.r = r;
            this.c = c;
            this.cnt = cnt;
        }
    }
}
```
