# [미로 탐색](https://www.acmicpc.net/problem/2178)

- [강지웅](#강지웅)
- [서예진](#서예진)
- [오나연](#오나연)
- [이주형](#이주형)
- [정윤영](#정윤영)

![image](https://user-images.githubusercontent.com/56468120/172032907-2018136b-b7c4-49e5-9b34-8c2f76b1b3e6.jpg)


## 강지웅
```swift
func mazes() {
    let dx: [Int] = [0, 0, -1, 1]
    let dy: [Int] = [1, -1, 0, 0]
    
    let input: [Int] = readLine()!.split(separator: " ").map{ Int($0)! }
    let N: Int = input[0]
    let M: Int = input[1]
    
    var point: [Int]
    var next: [Int]
    var queue: [[Int]] = [[0, 0, 0]]
    var maze: [[Character]] = []
    
    for _ in 0..<N {
        maze.append(readLine()!.map{$0})
    }
    
    maze[0][0] = "2"
    
    while(!queue.isEmpty){
        point = queue.removeFirst()
        point[2] += 1
        
        if point[0] == N - 1 && point[1] == M - 1{
            print("\(point[2])")
        }
        
        for i in 0..<4 {
            next = [point[0] + dx[i], point[1] + dy[i], point[2]]
            if next[0] < 0 || next[0] >= N || next[1] < 0 || next[1] >= M {
                continue
            }
            if maze[next[0]][next[1]] == "1"{
                queue.append(next)
                maze[next[0]][next[1]] = "2"
            }
        }
    }
}
```
## 서예진
```java

```

## 오나연
```java

```

## 이주형
```java
```

## 정윤영
```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.LinkedList;
import java.util.Queue;
import java.util.StringTokenizer;

public class BOJ_2178 {

    static int N, M;
    static int[][] arr;
    static int[][] deltas = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        StringTokenizer st = new StringTokenizer(br.readLine());

        N = Integer.parseInt(st.nextToken());
        M = Integer.parseInt(st.nextToken());

        arr = new int[N][M];

        for(int i=0; i<N; i++){
            String str = br.readLine();
            for(int j=0; j<M; j++){
                arr[i][j] = str.charAt(j) - '0';
            }
        }

        int cnt = bfs();

        System.out.println(cnt);

    }

    public static int bfs(){
        Queue<int[]> queue = new LinkedList<>();
        boolean[][] isVisited = new boolean[N][M];
        queue.add(new int[]{0, 0, 1});
        isVisited[0][0] = true;

        while(!queue.isEmpty()){
            int[] temp = queue.poll();
            int r = temp[0];
            int c = temp[1];
            int cnt = temp[2];

            if(r == N-1 && c == M-1){
                return cnt;
            }

            for(int i=0; i<4; i++){
                int dr = r + deltas[i][0];
                int dc = c + deltas[i][1];
                if(checkBoundary(dr, dc) && arr[dr][dc] == 1 && !isVisited[dr][dc]){
                    isVisited[dr][dc] = true;
                    queue.add(new int[]{dr, dc, cnt+1});
                }
            }
        }

        return 1;
    }

    public static boolean checkBoundary(int dr, int dc){
        return dr>=0 && dc>=0 && dr<N && dc<M;
    }
}

```
